## 排序算法

### 冒泡的算法

>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成.

```cgo
## 举例说明

arr = [24,69,80,57,13]

第一轮比较
第1次比较：24<69
第2次比较：69<80
第3次比较：80>57 --> [24,69,57,80,13] 
第4次比较：80>13 --> [24,69,57,13,80] 
第二轮比较
第1次比较：24<69
第2次比较：69>57 --> [24,57,69,13,80]
第3次比较：69>13 --> [24,57,13,69,80]
第三轮比较
第1次比较：24<57
第2次比较：57>13 --> [24,13,57,69,80]
第四轮比较
第1次比较：24>13 --> [13,24,57,69,80]

## 描述
1. 冒泡排序会经过arr.length-1轮次比较，每一轮会确认一个数字
2. 每一轮次数都会减少[4,3,2,1]
3. 当发现前面的数大于后面的数，就进行交换

```
源码[bubble](bubbleSort.go)

![图片](../images/bobulesort.gif)

### 选择排序

>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

```cgo
## 描述

1. 选择排序会经过arr.length-1轮次比较，每一轮会确认一个数字
2. 第i趟排序，在i+1到arr.length进行查找，找到最小的便放在i的位置上。
3. n-1次排序即可借宿

```
源码[select](selectSort.go)

![图片](../images/selectionsort.gif)
### 插入排序

> 1. 从第一个元素开始，该元素可以认为已经被排序
> 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
> 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
> 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
> 5. 将新元素插入到该位置后
> 6. 重复步骤2~5

```cgo
1. 插入排序会经过arr.length-1次比较，一轮排序完毕
2. 在第i次比较时,前i-1次序列已经排序完成，arr[i]<arr[i-1],借宿比较;
3. arr[i]>arr[i-1]时，arr[i] 交换 arr[i-1],在进行a[i-1]与a[i-2]

```
源码[insertion](insertionSort.go)

![图片](../images/insertionsort.gif)